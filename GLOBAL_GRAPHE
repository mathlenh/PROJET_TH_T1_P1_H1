import java.io.*;
import java.util.*;

public class Graphe {

    // ------- Représentation interne --------
    private Map<String, Integer> index = new HashMap<>();
    private List<String> noms = new ArrayList<>();

    private List<List<int[]>> adjOriente = new ArrayList<>();  // (v, w)
    private int[][] matNonOriente;  // Pour MST uniquement

    private int n;

    public int taille() { return n; }
    public String getNom(int i) { return noms.get(i); }
    public int getIndex(String nom) { return index.get(nom); }
    public List<int[]> getVoisinsOriente(int u) { return adjOriente.get(u); }
    public int[][] getMatriceNonOriente() { return matNonOriente; }

    // ----------------------------------------------------
    // CHARGEMENT DU FICHIER massy.txt AVEC ORIENTATION
    // Format : A ; B ; distance ; orientation
    // orientation = 0 → A↔B
    // orientation = 1 → A→B
    // orientation = 2 → B→A
    // ----------------------------------------------------
    public void charger(String fichier) throws Exception {

        BufferedReader br = new BufferedReader(new FileReader(fichier));
        String ligne;

        List<String[]> edges = new ArrayList<>();
        Set<String> uniqueNames = new HashSet<>();

        while ((ligne = br.readLine()) != null) {
            if (ligne.trim().isEmpty()) continue;

            String[] p = ligne.split(";");
            if (p.length < 4) {
                throw new RuntimeException("Format incorrect : " + ligne);
            }

            String A = p[0].trim();
            String B = p[1].trim();
            int dist = Integer.parseInt(p[2].trim());
            int orient = Integer.parseInt(p[3].trim());

            uniqueNames.add(A);
            uniqueNames.add(B);
            edges.add(new String[]{A, B, "" + dist, "" + orient});
        }
        br.close();

        // === Création des sommets ===
        n = uniqueNames.size();
        int id = 0;
        for (String nom : uniqueNames) {
            index.put(nom, id);
            noms.add(nom);
            id++;
        }

        // === Initialisation des structures ===
        for (int i = 0; i < n; i++)
            adjOriente.add(new ArrayList<>());

        matNonOriente = new int[n][n];
        for (int i = 0; i < n; i++)
            Arrays.fill(matNonOriente[i], 999999);
        for (int i = 0; i < n; i++)
            matNonOriente[i][i] = 0;

        // === Ajout des arêtes selon l’orientation ===
        for (String[] e : edges) {
            int u = index.get(e[0]);
            int v = index.get(e[1]);
            int d = Integer.parseInt(e[2]);
            int o = Integer.parseInt(e[3]);

            if (o == 0) {
                // A <-> B
                adjOriente.get(u).add(new int[]{v, d});
                adjOriente.get(v).add(new int[]{u, d});
                matNonOriente[u][v] = d;
                matNonOriente[v][u] = d;
            }
            else if (o == 1) {
                // A -> B
                adjOriente.get(u).add(new int[]{v, d});
                // Pour MST : on convertit en non orienté
                matNonOriente[u][v] = Math.min(matNonOriente[u][v], d);
                matNonOriente[v][u] = Math.min(matNonOriente[v][u], d);
            }
            else if (o == 2) {
                // B -> A
                adjOriente.get(v).add(new int[]{u, d});
                // Pour MST : on convertit en non orienté
                matNonOriente[u][v] = Math.min(matNonOriente[u][v], d);
                matNonOriente[v][u] = Math.min(matNonOriente[v][u], d);
            }
        }
    }
}
